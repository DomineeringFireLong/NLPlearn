# 时间与空间复杂度

## 时间复杂度
1. 定义：描述算法运行时间随输入规模增长的变化趋势。
2. 计算方法
    1. 找出基本操作：通常是执行次数最多的操作
    2. 计算执行次数：表示为输入规模n的函数T(n)
    3. 取最高阶项：忽略低阶项和常数系数

3. 常见时间复杂度
    - (1)：常数时间
    - O(log n)：对数时间
    - O(n)：线性时间
    - O(n log n)：线性对数时间
    - O(n²)：平方时间
    - O(n³)：立方时间
    - O(2ⁿ)：指数时间
    - O(n!)：阶乘时间



## 空间复杂度
1. 定义
空间复杂度(Space Complexity)描述算法运行过程中所需的存储空间随输入规模增长的变化趋势。
只考虑算法运行过程中额外申请的存储空间，不包括输入数据本身占用的空间。


2. 计算方法
    1. 考虑**额外空间**：不包括输入、输出数据本身占用的空间
    2. 计算变量、自函数等：分析随着输入增长而变化的存储需求
    3. 取最高阶项：忽略低阶项和常数系数




3. 常见空间复杂度
    - O(1)：常数空间
    - O(n)：线性空间
    - O(logn)：递归空间
    - O(n²)：平方空间
4. 靠虑因素
    1. 显式分配的额外数据结构
        动态创建的数组、链表、哈希表等
        临时变量或辅助数据结构
        示例：归并排序中用于合并的临时数组
    2. 递归调用栈空间（一般二分递归，都是logn，因为进行了logn次的深度递归）
        递归深度直接影响空间消耗
        每层递归保存的局部变量、参数和返回地址
        示例：快速排序递归调用栈平均需要 O(log n) 空间
    3.  隐式内存开销（子函数）
        函数调用时的栈帧（非递归算法也可能占用）
        动态语言中对象引用的开销（如 Python 的列表扩容）
    4. 算法特有的空间消耗
        某些算法需要预分配空间（如计数排序的计数数组）
        缓存或备忘录（如动态规划中的 DP 表）
5. 不需要考虑的因素
    输入数据本身占用的空间
        例如排序算法的输入数组不算额外空间
        但若算法修改了输入数据（如原地排序），则需特殊说明
    输出数据的空间
        若输出是算法要求的结果（如返回的新数组），通常不计入
        但若输出是临时中间结果（如某些回溯算法的路径记录），则需计入 

循环中的临时变量（如 int i）通常不计入，因为编译器会优化复用。

多重循环：嵌套循环的复杂度是各层循环复杂度的乘积  
递归算法：通常时间复杂度为递归调用次数乘以每次调用的操作数  
分摊分析：某些操作可能偶尔耗时，但平均下来效率很高  
最坏/平均/最好情况：通常关注最坏情况复杂度  







## 例子
1. 递归算法分析
    def fibonacci(n):
        if n <= 1:
            return n
        return fibonacci(n-1) + fibonacci(n-2)
    时间复杂度：O(2ⁿ)
        递归树每层分裂为 2 个子问题，深度为 n，总节点数为 2ⁿ-1（近似 O(2ⁿ)）。
        优化方式：用动态规划可降至 O(n)。
    空间复杂度：O(n)
        递归调用栈的最大深度为 n（如计算 fibonacci(n) 需先压栈 n 层）。
        注意：尽管函数没有显式分配数组，但递归栈隐式占用了空间。

2. 分治算法分析
    def divide_conquer(arr, l, r):
        if l >= r:
            return
        mid = (l + r) // 2
        divide_conquer(arr, l, mid)      # 递归左半
        divide_conquer(arr, mid+1, r)    # 递归右半
        merge(arr, l, mid, r)            # 合并操作，时间复杂度 O(r-l)

    时间复杂度：O(n log n)
        递归树深度为 log n，每层合并操作总时间为 O(n)（所有合并加起来处理全部元素）。
        典型例子：归并排序。
    空间复杂度：O(n)
        递归栈深度为 O(log n)，但合并操作可能需要额外 O(n) 的临时数组（如归并排序）。
        注意：若合并是原地操作（如某些链表合并），空间复杂度可优化至 O(log n)。



3. 动态规划分析

    def coin_change(coins, amount):
        dp = [float('inf')] * (amount + 1)  # 初始化 DP 数组
        dp[0] = 0
        for coin in coins:
            for i in range(coin, amount+1):
                dp[i] = min(dp[i], dp[i-coin] + 1)
        return dp[amount] if dp[amount] != float('inf') else -1

    时间复杂度：O(S×n)
        S 是金额 amount，n 是硬币种类数。
        双重循环：外层遍历硬币（n 次），内层遍历金额（S 次）。

    空间复杂度：O(S)
        dp 数组的长度为 amount + 1，与硬币种类数无关。
        优化方向：若用滚动数组，空间可降至 O(max(coins))。


4. 字符串匹配算法
    def count_substrings(s):
        count = 0
        for i in range(len(s)):
            for j in range(i, len(s)):
                if s[i] == s[j]:
                    count += 1
        return count
    
    时间复杂度：O(n²)
        双重循环，外层 n 次，内层平均 n/2 次，总计 O(n²)。
    空间复杂度：O(1)
        仅使用固定数量的变量（count, i, j）。


5.  回溯算法分析
    def backtrack(nums, path, res):
        if len(path) == len(nums):
            res.append(path.copy())
            return
        for num in nums:
            if num not in path:
                path.append(num)
                backtrack(nums, path, res)
                path.pop()

    时间复杂度：O(n×n!)
        全排列共有 n! 种，每种需要 O(n) 时间复制到结果中。
    空间复杂度：O(n)
        递归栈深度为 n（排列长度），临时路径 path 的空间为 O(n)。
        注意：结果集 res 的空间不计入（属于输出）。





    

